#include "global.h"

int _gSenseLineNum = 0;
int _gDriveLineNum = 0;
int _gWaterProofNum = 0;
int _gDeltaC[MAX_MUTUAL_NUM] = { 0 };
int _gDeltaCVA[MAX_MUTUAL_NUM] = { 0 };

int *_gResult = NULL;
extern int Mstar_save_failed_node(int iRow, int iCol);

void Msg28xxSetMutualCsubViaDBbus(s16 nCSub)
{
	u8 nBaseLen = 6;
	u16 nFilter = 0x3F;
	u16 nLastFilter = 0xFFF;
	u8 nBasePattern = nCSub & nFilter;
	u8 nPattern;
	u16 n16BitsPattern;
	u16 nCSub16Bits[5] = { 0 };
	int i;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	for (i = 0; i < 5; i++) {
		if (i == 0) {
			nPattern = nBasePattern;	/*Patn => Pattern */
		}

		n16BitsPattern = ((nPattern & 0xF) << nBaseLen * 2) | (nPattern << nBaseLen) | nPattern;

		if (i == 4) {
			nCSub16Bits[i] = n16BitsPattern & nLastFilter;
		} else {
			nCSub16Bits[i] = n16BitsPattern;
		}
		nPattern = (u8) ((n16BitsPattern >> 4) & nFilter);
	}

	RegSet16BitValue(0x215C, 0x1FFF);

	for (i = 0; i < 5; i++) {
		RegSet16BitValue(0x2148 + 2 * i, nCSub16Bits[i]);
		RegSet16BitValue(0x2152 + 2 * i, nCSub16Bits[i]);
	}
}

void Msg28xxAFEGainOne(void)
{
	/*AFE gain = 1X */
	u16 nAfeGain = 0;
	u16 nDriOpening = 0;
	u8 nRegData = 0;
	u16 nAfeCoef = 0;
	u16 i = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);
	nRegData = RegGetLByteValue(0x1312);	/*get dri num */
	nDriOpening = nRegData;

	/*filter unit gain */
	if (nDriOpening == 11 || nDriOpening == 15) {
		RegSet16BitValue(0x1318, 0x4470);
	} else if (nDriOpening == 7 || nDriOpening == 4) {
		RegSet16BitValue(0x1318, 0x4460);
	} else if (nDriOpening == 1) {
		RegSet16BitValue(0x1318, 0x4440);
	}

	RegSet16BitValue(0x131A, 0x4444);

	/*AFE coef */
	nRegData = RegGetLByteValue(0x101A);
	nAfeCoef = 0x10000 / nRegData;
	RegSet16BitValue(0x13D6, nAfeCoef);

	/*AFE gain */
	if (nDriOpening == 7 || nDriOpening == 15 || nDriOpening == 4 || nDriOpening == 1) {
		nAfeGain = 0x0040;
	} else if (nDriOpening == 11) {
		nAfeGain = 0x0055;
	}

	for (i = 0; i < 13; i++) {
		RegSet16BitValue(0x2160 + 2 * i, nAfeGain);
	}

	/*AFE gain: over write enable */
	RegSet16BitValue(0x217A, 0x1FFF);
	RegSet16BitValue(0x217C, 0x1FFF);

	/*all AFE Cfb use defalt (50p) */
	RegSet16BitValue(0x1508, 0x1FFF);	/*all AFE Cfb: SW control */
	if (ptMutualMpTest->Pattern_type == 5) {
		switch (ptMutualMpTest->Open_test_cfb) {
		case 0:
		case 2:
			SetCfb(_20p);
			break;
		case 1:
			SetCfb(_10p);
			break;
		case 3:
			SetCfb(_30p);
			break;
		case 4:
			SetCfb(_40p);
			break;
		case 5:
			SetCfb(_50p);
			break;
		}
		TEST_DBG(0, "SetCfb : %d\n", ptMutualMpTest->Open_test_cfb);
	} else {
		RegSet16BitValue(0x1550, 0x0000);	/*all AFE Cfb use defalt (50p) */
	}

	/*reg_hvbuf_sel_gain */
	RegSet16BitValue(0x1564, 0x0077);

	/*ADC: AFE Gain bypass */
	RegSet16BitValue(0x1260, 0x1FFF);
}

void Msg28xxCalibrateMutualCsub(s16 nCSub)
{
	u8 nChipVer;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	nChipVer = RegGetLByteValue(0x1ECE);
	TEST_DBG(0, "*** Msg28xx Open Test# Chip ID = %d ***\n", nChipVer);

	if (nChipVer != 0)
		RegSet16BitValue(0x10F0, 0x0004);	/*bit2 */

	Msg28xxSetMutualCsubViaDBbus(nCSub);
	Msg28xxAFEGainOne();
}

void Msg28xxAnaEnableChargePump(u8 enable_charge_pump)
{
	u16 val = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);
	if (!enable_charge_pump) {
		RegSet16BitValueOff(0x1560, BIT0 | BIT1);	/*high v buf en, close */

		val = RegGet16BitValue(0x1566);	/*set */
		val |= BIT12;
		RegSet16BitValue(0x1566, val);	/*LV on */

		RegSet16BitValueOff(0x1566, BIT8 | BIT9 | BIT10 | BIT11);

		RegSet16BitValueOff(0x1570, BIT8 | BIT10);

		RegSet16BitValueOff(0x1580, BIT0 | BIT4);

		val = RegGet16BitValue(0x1464);	/*set */
		val |= BIT2 | BIT3;
		RegSet16BitValue(0x1464, val);
	} else {
		val = RegGet16BitValue(0x1560);	/*set */
		val |= 0x03;
		RegSet16BitValue(0x1560, val);	/*high v buf en, close */

		RegSet16BitValueOff(0x1566, BIT12);	/*LV on */

		RegSet16BitValueOff(0x1566, BIT8 | BIT9 | BIT10 | BIT11);	/*LV on */

		val = RegGet16BitValue(0x1566);	/*set */
		val |= BIT8 | BIT10;
		RegSet16BitValue(0x1566, val);

		val = RegGet16BitValue(0x1570);	/*cset */
		val |= BIT10;
		RegSet16BitValue(0x1570, val);

		val = RegGet16BitValue(0x1580);	/*set */
		val |= BIT0 | BIT1;
		RegSet16BitValue(0x1580, val);

		RegSet16BitValueOff(0x1464, BIT2 | BIT3);
	}
}

void Msg28xxOpenSineModeSetting(void)
{
/*u8 nCfb = ptMutualMpTest->Open_test_cfb;*/
	TEST_DBG(0, "*** %s() ***\n", __func__);
	Msg28xxAnaEnableChargePump(ptMutualMpTest->Open_test_chargepump);
	switch (ptMutualMpTest->Open_test_cfb) {
	case 0:
	case 2:
		SetCfb(_20p);
		break;
	case 1:
		SetCfb(_10p);
		break;
	case 3:
		SetCfb(_30p);
		break;
	case 4:
		SetCfb(_40p);
		break;
	case 5:
		SetCfb(_50p);
		break;
	}
	TEST_DBG(0, "SetCfb : %d\n", ptMutualMpTest->Open_test_cfb);
}

void Msg28xxUpdateAnaChargeDumpSetting(void)
{
	TEST_DBG(0, "*** %s() ***\n", __func__);
	RegSet16BitValueByAddressMode(0x1018, 0x001F, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x1019, 0x003f, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x101a, 0x0028, ADDRESS_MODE_16BIT);	/*post idle time in sub0 */
	RegSet16BitValueByAddressMode(0x101b, 0x0028, ADDRESS_MODE_16BIT);	/*post idle time in sub1 */
	RegSet16BitValueByAddressMode(0x101c, 0x0028, ADDRESS_MODE_16BIT);	/*post idle time in sub2 */
	RegSet16BitValueByAddressMode(0x101d, 0x0028, ADDRESS_MODE_16BIT);	/*post idle time in sub3 */
	RegSet16BitValueByAddressMode(0x101e, 0x0028, ADDRESS_MODE_16BIT);	/*post idle time in sub4 */
	RegSet16BitValueByAddressMode(0x101f, 0x0000, ADDRESS_MODE_16BIT);

	RegSet16BitValueByAddressMode(0x100d, 0x0020, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x1103, 0x0020, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x1104, 0x0020, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x1302, 0x0020, ADDRESS_MODE_16BIT);
	/*AFE_coef, set value by 0x10000 dividing register 0x100d value */
	RegSet16BitValueByAddressMode(0x136b, 0x10000 / 0x20, ADDRESS_MODE_16BIT);
	RegSet16BitValueByAddressMode(0x1b30, 0x0020, ADDRESS_MODE_16BIT);
}

s32 Msg28xxReEnterMutualMode(u16 nFMode)
{
	TEST_DBG(0, "*** %s() ***\n", __func__);

	StartMCU();
	/*EnterDBBus(); */
	Msg28xxDBBusReEnter();
	/*usleep(50000); */
	mdelay(50);
	RegSet16BitValue(0x1402, nFMode);
	TEST_DBG(0, "nFMode = %x\n", nFMode);
	if (Msg28xxCheckSwitchStatus() < 0) {
		pr_err("*** %s: Msg28xx MP Test# CheckSwitchStatus failed! ***\n", __func__);
		return -EPERM;
	}

	StopMCU();
	RegSet16BitValue(0x3D08, 0xFEFF);	/*open timer */
	return 0;
}

s32 Msg28xxGetDeltaC(s32 *pDeltaC)
{
	s16 *pRawData = NULL;
	/*s16 pRawData[MAX_CHANNEL_SEN * 2 * MAX_CHANNEL_DRV]; */
	/*s16 nRawDataOverlapDone[_gSenseLineNum][_gDriveLineNum]; */

	s16 **nRawDataOverlapDone = NULL;
	/*s16 nDeltaC[MAX_MUTUAL_NUM] = {0}; */
	u16 nDrvPos = 0, nSenPos = 0, nShift = 0;
	u16 nSenNumBak = 0;
	u16 nDrvNumBak = 0;
	s16 i, j;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	pRawData = kmalloc(sizeof(s16) * MAX_CHANNEL_SEN * 2 * MAX_CHANNEL_DRV, GFP_KERNEL);
	nRawDataOverlapDone = kmalloc((_gSenseLineNum * sizeof(s16 *)), GFP_KERNEL);
	for (i = 0; i < _gSenseLineNum; ++i) {
		nRawDataOverlapDone[i] = kmalloc((_gDriveLineNum * sizeof(s16)), GFP_KERNEL);
	}
	memset(pRawData, 0, sizeof(*pRawData));
	for (i = 0; i < _gSenseLineNum; ++i) {
		memset(nRawDataOverlapDone[i], 0, _gDriveLineNum * sizeof(s16));
	}
	if (Msg28xxGetMutualOneShotRawIIR(pRawData, &nSenNumBak, &nDrvNumBak) < 0) {
		pr_err("*** Msg28xx Open Test# GetMutualOneShotRawIIR failed! ***\n");
		kfree(pRawData);
		for (i = 0; i < _gSenseLineNum; ++i) {
			kfree(nRawDataOverlapDone[i]);
		}
		kfree(nRawDataOverlapDone);
		return -EPERM;
	}

	TEST_DBG(0, "*** Msg28xx Open Test# nSenNumBak=%d nDrvNumBak=%d ***\n", nSenNumBak, nDrvNumBak);

	for (i = 0; i < _gSenseLineNum; i++) {
		for (j = 0; j < _gDriveLineNum; j++) {
			nRawDataOverlapDone[i][j] = UN_USE_SENSOR;
		}
	}

	TEST_DBG(0, "*** Msg28xx Open Test# *****\n");

	for (i = 0; i < nSenNumBak; i++) {
		for (j = 0; j < nDrvNumBak; j++) {
			nShift = (u16) (i * nDrvNumBak + j);

			nDrvPos = ptMutualMpTest->sensorInfo.mapping[nShift].Y;
			nSenPos = ptMutualMpTest->sensorInfo.mapping[nShift].X;

			if (nDrvPos >= _gDriveLineNum || nSenPos >= _gSenseLineNum)
				continue;

			if (nDrvPos != 0xFF && nSenPos != 0xFF) {
				nRawDataOverlapDone[nSenPos][nDrvPos] = pRawData[i * MAX_CHANNEL_DRV + j];
			}
		}
	}

	TEST_DBG(0, "*** Msg28xx Open Test# Transfer nRawDataOverlapDone to pDeltaC");
	for (i = 0; i < _gSenseLineNum; i++) {
		for (j = 0; j < _gDriveLineNum; j++) {
			nShift = (u16) (i * _gDriveLineNum + j);
			pDeltaC[nShift] = (s32) nRawDataOverlapDone[i][j];
		}
	}

	TEST_DBG(0, "*** Msg28xx Open Test# gDeltaC ***\n");
	DebugShowArray2(pDeltaC, _gSenseLineNum * _gDriveLineNum, -32, 10, _gSenseLineNum);
	kfree(pRawData);
	for (i = 0; i < _gSenseLineNum; ++i) {
		kfree(nRawDataOverlapDone[i]);
	}

	kfree(nRawDataOverlapDone);
	return 0;
}

void _HalSramEnterAccessMode(void)
{
	TEST_DBG(0, "*** %s() ***\n", __func__);
	/*change to R2 mode */
	RegMask16BitValue(0x2149, BIT5, BIT5, ADDRESS_MODE_16BIT);
	/*SRAM using MCU clock */
	RegMask16BitValue(0x1E11, BIT13, BIT13, ADDRESS_MODE_16BIT);
}

void _HalSramExitAccessMode(void)
{
	TEST_DBG(0, "*** %s() ***\n", __func__);
	/*change to R2 mode */
	RegMask16BitValue(0x2149, BIT5, 0, ADDRESS_MODE_16BIT);
	/*SRAM using MCU clock */
	RegMask16BitValue(0x1E11, BIT13, 0, ADDRESS_MODE_16BIT);
}

void Msg28xxOpenSwcapModeSetting(void)
{
	u16 chargeT = 0x0C, dumpT = 0x06;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	/*Stop mcu */
	StopMCU();

	Msg28xxCalibrateMutualCsub(ptMutualMpTest->Open_test_csub);
	Msg28xxAnaChangeCDtime(chargeT, dumpT);
	Msg28xxAnaEnableChargePump(DISABLE);
	RegSet16BitValue(0x156A, 0x000A);	/*DAC com voltage */
	Msg28xxUpdateAnaChargeDumpSetting();
	Msg28xxAnaSwReset();
}

s32 ObtainOpenValue_VA_FW_v1007(void)
{
	if (Msg28xxGetDeltaC(_gDeltaC) < 0) {
		TEST_DBG(0, "*** Msg28xx Open Test# GetDeltaC failed! ***\n");
		return -EPERM;
	}
	return 0;
}

void _WriteDQMem_8bit(u16 addr, u8 data)
{
	u8 read_buf[4] = { 0 };
	u16 high_16, low_16 = 0;
	u16 read_addr = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	read_addr = addr - (addr % 4);

	RegGet16BitByteValueBuf(read_addr, read_buf, sizeof(read_buf));

	read_buf[addr % 4] = data;
	TEST_DBG(0, "read_buf:0x%02x 0x%02x 0x%02x  0x%02x", read_buf[0], read_buf[1], read_buf[2],
		 read_buf[3]);
	low_16 = (((u16) read_buf[1] << 8) | read_buf[0]);
	high_16 = (((u16) read_buf[3] << 8) | read_buf[2]);

	RegSet16BitValue(read_addr + 2, low_16);
	RegSet16BitValue(read_addr, high_16);
}

s32 Msg28xxObtainOpenValue_Keys_FW_v1007(int *pkeyarray)
{
	int k;
/*u8 u8ShotData[16];*/
	/*u16 nSf = ptMutualMpTest->sub_frame; */
	u8 nRegData = 0, nSf = 0;
	u16 numKey = 0, drvNum = 0, senNum = 0;
/*u16 keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];*/
	u32 shift = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);
	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData >> 4;
	SetCfb(_50p);
	Msg28xxAnaEnableChargePump(DISABLE);
	/*Msg28xxAnaSwReset(); */
	if (Msg28xxGetValueR(_gDeltaCVA) < 0) {
		/*if(Msg28xxGetDeltaC(_gDeltaCVA) < 0) { */
		TEST_DBG(0, "*** Msg28xx Open Test# GetDeltaC failed! ***\n");
		return -EPERM;
	}

	numKey = ptMutualMpTest->sensorInfo.numKey;
	drvNum = ptMutualMpTest->sensorInfo.numDrv;
	senNum = ptMutualMpTest->sensorInfo.numSen;

	if (MAX(numKey, 3) > 3)
		numKey = 3;
	shift = 0;
	for (k = 0; k < numKey; k++) {
		pkeyarray[k] = _gDeltaCVA[k];
	}
	return 0;
}

s32 ObtainOpenValue_VA(void)
{
	int i, isf = 0;
	u8 u8ShotData[16];
	/*u16 nSf = ptMutualMpTest->sub_frame; */
	u8 nSf = 0, nRegData = 0;
	u16 addr = 0x6410;
	u16 keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];

	TEST_DBG(0, "*** %s() ***\n", __func__);
	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData >> 4;
	_HalSramEnterAccessMode();
	for (isf = 0; isf < nSf; isf++) {
		memset(u8ShotData, 0, sizeof(u8ShotData));
		Msg28xxDBBusReadDQMemStart();
		/*RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0])); */
		RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData),
				MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
		/*Find key index, then replace key sensor by assign sensor 56(0x38). */
		TEST_DBG(0, "Check KeySen : %d", keySen);
		for (i = 0; i < sizeof(u8ShotData); i++) {
			TEST_DBG(0, "Loop Count : %d", i);
			if (u8ShotData[i] == keySen)
				_WriteDQMem_8bit(addr + isf * 0x20 + i, 0x38);
		}
		/*RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0])); */
		RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData),
				MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		DebugShowArray2(u8ShotData, 16, 16, 16, 16);
		Msg28xxDBBusReadDQMemEnd();
	}
	_HalSramExitAccessMode();
	Msg28xxAnaSwReset();
	if (Msg28xxGetDeltaC(_gDeltaC) < 0) {
		pr_err("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
		return -EPERM;
	}
	TEST_DBG(0, "*** ObtainOpenValue_VA End ***\n");
	return 0;
}

s32 Msg28xxObtainOpenValue_Keys(int *pkeyarray)
{
	int k;
	int i, isf = 0;
	u8 u8ShotData[16];
	/*u16 nSf = ptMutualMpTest->sub_frame; */
	u8 nSf = 0, nRegData = 0;
	u16 addr = 0x6410, numKey = 0, drvNum = 0, senNum = 0;
	u16 keySen = 0;
	u32 shift = 0;

	keySen = ptMutualMpTest->PAD2Drive[ptMutualMpTest->sensorInfo.KeyDrv_o - 1];

	TEST_DBG(0, "*** %s() ***\n", __func__);

	nRegData = RegGetLByteValue(0x130A);
	nSf = nRegData >> 4;
	SetCfb(_50p);
	Msg28xxAnaEnableChargePump(DISABLE);
	_HalSramEnterAccessMode();
	for (isf = 0; isf < nSf; isf++) {
		memset(u8ShotData, 0, sizeof(u8ShotData));
		Msg28xxDBBusReadDQMemStart();
		/*RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0])); */
		RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData),
				MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		/*Find key index, then replace key sensor by assign sensor 56(0x38). */
		for (i = 0; i < (sizeof(u8ShotData) / sizeof(u8)); i++) {
			TEST_DBG(0, "Loop Count : %d", i);
			if (u8ShotData[i] == 0x38) {
				_WriteDQMem_8bit(addr + isf * 0x20 + i, keySen);
				TEST_DBG(0, "keySen : %d", keySen);
			}
		}
		/*RegGetXByteValue(u8ShotData, addr + 0x20 * isf, sizeof(u8ShotData) / sizeof(u8ShotData[0])); */
		RegGetXBitValue(addr + 0x20 * isf, u8ShotData, sizeof(u8ShotData),
				MAX_I2C_TRANSACTION_LENGTH_LIMIT);
		Msg28xxDBBusReadDQMemEnd();
	}
	_HalSramExitAccessMode();
	Msg28xxAnaSwReset();
	if (Msg28xxGetDeltaC(_gDeltaCVA) < 0) {
		TEST_DBG(0, "*** Msg28xx Open Test# GetDeltaC failed! ***\n");
		return -EPERM;
	}
	numKey = ptMutualMpTest->sensorInfo.numKey;
	drvNum = ptMutualMpTest->sensorInfo.numDrv;
	senNum = ptMutualMpTest->sensorInfo.numSen;
	if (MAX(numKey, 3) > 3)
		numKey = 3;

	for (k = 0; k < numKey; k++) {
		shift =
		    (ptMutualMpTest->KeySen[k] - 1) * ptMutualMpTest->sensorInfo.KeyDrv_o +
		    ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
		pkeyarray[k] = _gDeltaCVA[shift];
	}
	return 0;
}

s32 Msg28xxopen_latter_FW_v1007(u16 nFMode)
{
	int *keyArray = NULL, k, numKey = 0;
	u16 shift = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	/*Stop mcu */
	StopMCU();
	TEST_DBG(0, "nFMode = %x\n", nFMode);
	if (nFMode == MUTUAL_SINE)
		Msg28xxOpenSineModeSetting();
	else
		Msg28xxOpenSwcapModeSetting();

	numKey = ptMutualMpTest->sensorInfo.numKey;

	if (MAX(numKey, 3) > 3)
		numKey = 3;
	if (ptMutualMpTest->Mutual_Key != 0) {

		u16 fmodeKey;

		if (nFMode == MUTUAL_SINE)
			fmodeKey = MUTUAL_SINE_KEY;
		else
			fmodeKey = MUTUAL_KEY;

		keyArray = kcalloc(numKey, sizeof(int), GFP_KERNEL);

		if (ObtainOpenValue_VA_FW_v1007() < 0) {
			TEST_DBG(0, "*** ObtainOpenValue_VA failed ***\n");
			if (keyArray != NULL)
				kfree(keyArray);
			return -EPERM;
		}

		if (nFMode == MUTUAL_SINE)
			Msg28xxOpenSineModeSetting();
		else
			Msg28xxOpenSwcapModeSetting();

		if (Msg28xxReEnterMutualMode(fmodeKey) < 0) {
			TEST_DBG(0, "*** Msg28xxReEnterMutualMode failed ***\n");
			if (keyArray != NULL)
				kfree(keyArray);
			return -EPERM;
		}

		if (Msg28xxObtainOpenValue_Keys_FW_v1007(keyArray) < 0) {
			TEST_DBG(0, "*** Msg28xxObtainOpenValue_Keys failed ***\n");
			if (keyArray != NULL)
				kfree(keyArray);
			return -EPERM;
		}

		for (k = 0; k < numKey; k++) {
			shift =
			    (ptMutualMpTest->KeySen[k] - 1) * ptMutualMpTest->sensorInfo.KeyDrv_o +
			    ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
			_gDeltaC[shift] = keyArray[k];
		}
	} else {
		if (Msg28xxGetDeltaC(_gDeltaC) < 0) {
			TEST_DBG(0, "*** Msg28xx Open Test# GetDeltaC failed! ***\n");
			if (keyArray != NULL)
				kfree(keyArray);
			return -EPERM;
		}
	}
	if (keyArray != NULL) {
		TEST_DBG(0, "*** free keyArray ***\n");
		kfree(keyArray);
	}
	return 0;
}

s32 Msg28xxopen_previous_FW_v1007(u16 nFMode)
{
	int *keyArray = NULL, k, numKey;
	u16 shift = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	/*Stop mcu */
	StopMCU();

	numKey = ptMutualMpTest->sensorInfo.numKey;

	if (MAX(numKey, 3) > 3)
		numKey = 3;
	if (ptMutualMpTest->Mutual_Key != 0) {

		if (ptMutualMpTest->Open_mode == 2) {
			if (Msg28xxopen_latter_FW_v1007(nFMode) < 0) {
				pr_err("*** Msg28xx Open Test# OpenTest failed! ***\n");
				return -EPERM;
			}
		} else {
			if ((ptMutualMpTest->Pattern_type == 5) && (ptMutualMpTest->Pattern_model == 1)) {
				if (nFMode == MUTUAL_SINE)
					Msg28xxOpenSineModeSetting();
				else
					Msg28xxOpenSwcapModeSetting();

				keyArray = kcalloc(numKey, sizeof(int), GFP_KERNEL);
				if (ObtainOpenValue_VA() < 0) {
					pr_err("*** ObtainOpenValue_VA failed ***\n");
					if (keyArray != NULL)
						kfree(keyArray);
					return -EPERM;
				}

				if (Msg28xxReEnterMutualMode(nFMode) < 0) {
					pr_err("*** Msg28xxReEnterMutualMode failed ***\n");
					if (keyArray != NULL)
						kfree(keyArray);
					return -EPERM;
				}

				if (nFMode == MUTUAL_SINE)
					Msg28xxOpenSineModeSetting();
				else
					Msg28xxOpenSwcapModeSetting();

				if (Msg28xxObtainOpenValue_Keys(keyArray) < 0) {
					pr_err("*** Msg28xxObtainOpenValue_Keys failed ***\n");
					if (keyArray != NULL)
						kfree(keyArray);
					return -EPERM;
				}

				for (k = 0; k < numKey; k++) {
					shift =
					    (ptMutualMpTest->KeySen[k] -
					     1) * ptMutualMpTest->sensorInfo.KeyDrv_o +
					    ptMutualMpTest->sensorInfo.KeyDrv_o - 1;
					_gDeltaC[shift] = keyArray[k];
				}
			} else {
				if (nFMode == MUTUAL_SINE)
					Msg28xxOpenSineModeSetting();
				else
					Msg28xxOpenSwcapModeSetting();

				if (Msg28xxGetDeltaC(_gDeltaC) < 0) {
					pr_err("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
					if (keyArray != NULL)
						kfree(keyArray);
					return -EPERM;
				}
			}
		}
	} else {
		if (nFMode == MUTUAL_SINE)
			Msg28xxOpenSineModeSetting();
		else
			Msg28xxOpenSwcapModeSetting();

		if (Msg28xxGetDeltaC(_gDeltaC) < 0) {
			pr_err("*** Msg28xx Open Test# GetDeltaC failed! ***\n");
			if (keyArray != NULL)
				kfree(keyArray);
			return -EPERM;
		}
	}
	if (keyArray != NULL) {
		TEST_DBG(0, "*** free keyArray ***\n");
		kfree(keyArray);
	}
	return 0;
}

u16 normalTestFail_check_Deltac[MAX_MUTUAL_NUM];
u16 normalTestFail_check_Ratio[MAX_MUTUAL_NUM];
#ifndef DISABLE_DOUBLE
double ratio_border[MAX_MUTUAL_NUM];
double ratio_move[MAX_MUTUAL_NUM];
double ratio_border_move[MAX_MUTUAL_NUM];
double ratio[MAX_MUTUAL_NUM];
#else
int ratio_border[MAX_MUTUAL_NUM];
int ratio_move[MAX_MUTUAL_NUM];
int ratio_border_move[MAX_MUTUAL_NUM];
int ratio[MAX_MUTUAL_NUM];
#endif

s32 Msg28xxOpenJudge(u16 nItemID, s8 *pNormalTestResult, u16 *pNormalTestResultCheck)
{
	s32 nRetVal = 0;
	u16 nCSub = 0;
	u16 nRowNum = 0, nColumnNum = 0;
	u16 i, j, k;
	u16 nCfb;
	s32 bg_per_csub = 0;
#ifndef DISABLE_DOUBLE
	double ratioAvg = 0.0, ratioAvg_max = 0.0, ratioAvg_min = 0.0, passCount = 0.0;
	double ratioAvg_border = 0.0, ratioAvg_border_max = 0.0, ratioAvg_border_min = 0.0, passCount1 = 0.0;
	double ratioAvg_move = 0.0, ratioAvg_border_move = 0.0;
#else
	int ratioAvg = 0, ratioAvg_max = 0, ratioAvg_min = 0, passCount = 0;
	int ratioAvg_border = 0, ratioAvg_border_max = 0, ratioAvg_border_min = 0, passCount1 = 0;
	int ratioAvg_move = 0, ratioAvg_border_move = 0;
#endif

	nCSub = ptMutualMpTest->Open_test_csub;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	if ((ptMutualMpTest->Open_mode == 1) || (ptMutualMpTest->Open_mode == 2))
		nCSub = 0;

	if (!ptMutualMpTest->Open_test_cfb)
		nCfb = 2;
	else
		nCfb = ptMutualMpTest->Open_test_cfb;
#ifndef DISABLE_DOUBLE
	bg_per_csub = (int)(2.4 * 1.17 * 32768 / (11 * nCfb));
#else
	bg_per_csub = (int)(92012 / (11 * nCfb));
#endif
	for (i = 0; i < _gSenseLineNum * _gDriveLineNum; i++) {
		if (_gDeltaC[i] > 31000) {
			return -EPERM;
		}
		if (_gDeltaC[i] != UN_USE_SENSOR) {
			if (ptMutualMpTest->Pattern_type == 5)
				_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
			else
				_gResult[i] = 1673 * nCSub - _gDeltaC[i];
		} else
			_gResult[i] = NULL_DATA;
		/*For mutual key, last column if not be used, show number "one". */
		if ((ptMutualMpTest->Mutual_Key == 1 || ptMutualMpTest->Mutual_Key == 2)
		    && (ptMutualMpTest->sensorInfo.numKey != 0)) {
			if (ptMutualMpTest->Pattern_type == 5) {
				/*KEY_CH = 1, it mean keys in same drive.
				Current one key project only KEY_CH = 1 type. */
				if (ptMutualMpTest->sensorInfo.numKey != ptMutualMpTest->sensorInfo.KEY_CH) {
					if (!((i + 1) % ptMutualMpTest->sensorInfo.numDrv)) {
						_gResult[i] = NULL_DATA;
						for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
							if ((i + 1) / _gDriveLineNum == ptMutualMpTest->KeySen[k]) {
								if (ptMutualMpTest->Pattern_model == 1)
									_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
								else
									_gResult[i] = 1673 * nCSub - _gDeltaC[i];
							}
					}
				} else {
					if (i > ((ptMutualMpTest->sensorInfo.numSen - 1) *
						ptMutualMpTest->sensorInfo.numDrv - 1)) {
						_gResult[i] = NULL_DATA;
						for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
							if (((i + 1) - (_gSenseLineNum - 1) * _gDriveLineNum) ==
							    ptMutualMpTest->KeySen[k]) {
								if (ptMutualMpTest->Pattern_model == 1)
									_gResult[i] = bg_per_csub * nCSub - _gDeltaC[i];
								else
									_gResult[i] = 1673 * nCSub - _gDeltaC[i];
							}
					}
				}
			} else {
				if ((_gSenseLineNum < _gDriveLineNum) && ((i + 1) % _gDriveLineNum == 0)) {
					_gResult[i] = NULL_DATA;
					for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++)
						if ((i + 1) / _gDriveLineNum == ptMutualMpTest->KeySen[k]) {
							_gResult[i] = 1673 * nCSub - _gDeltaC[i];
						}
				}

				if ((_gSenseLineNum > _gDriveLineNum)
				    && (i > (_gSenseLineNum - 1) * _gDriveLineNum - 1)) {
					_gResult[i] = NULL_DATA;
					for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++) {
						if (((i + 1) - (_gSenseLineNum - 1) * _gDriveLineNum) ==
						    ptMutualMpTest->KeySen[k]) {
							_gResult[i] = 1673 * nCSub - _gDeltaC[i];
						}
					}	/*for (k = 0; k < ptMutualMpTest->sensorInfo.numKey; k++) */
				}
			}
		}
	}
/*golden*/
/*checking golden + ratio*/

	memset(normalTestFail_check_Deltac, 0xFF, sizeof(normalTestFail_check_Deltac));
	memset(normalTestFail_check_Ratio, 0xFF, sizeof(normalTestFail_check_Ratio));
	memset(ratio, 0, sizeof(ratio));
	memset(ratio_border, 0, sizeof(ratio_border));
	memset(ratio_move, 0, sizeof(ratio_move));
	memset(ratio_border_move, 0, sizeof(ratio_move));

	nRowNum = _gDriveLineNum;
	nColumnNum = _gSenseLineNum;

	TEST_DBG(0, "*** Msg28xx Open Test# Show _gResult ***\n");
	DebugShowArray2(_gResult, nRowNum * nColumnNum, -32, 10, nColumnNum);	/*debug sign 32 decimal value array */
	TEST_DBG(0, "*** Msg28xx Open Test# Show Goldensample ***\n");
	DebugShowArray2(ptMutualMpTest->Goldensample_CH_0, nRowNum * nColumnNum, -32, 10, nColumnNum);
	for (k = 0; k < (sizeof(_gDeltaC) / sizeof(int)); k++) {
		if (ptMutualMpTest->Goldensample_CH_0[k] == 0) {
			if (k == 0)
				pNormalTestResult[0] = 1;	/*no golden sample */
			break;
		}

		if (_gResult[k] != NULL_DATA) {
			ratio[k] = (_gResult[k] * 1000) / ptMutualMpTest->Goldensample_CH_0[k];

			if (0 ==
			    CheckValueInRange(_gResult[k], ptMutualMpTest->Goldensample_CH_0_Max[k],
					      ptMutualMpTest->Goldensample_CH_0_Min[k])) {
				pNormalTestResult[0] = 1;
				pNormalTestResultCheck[k] =
				    (u16) (((k / _gDriveLineNum) + 1) * 100 + ((k % _gDriveLineNum) + 1));
			} else {
				pNormalTestResultCheck[k] = PIN_NO_ERROR;
				if ((ptMutualMpTest->Pattern_type == 3)
				    && (ptMutualMpTest->sensorInfo.numKey == 0) && ((k % _gDriveLineNum == 0)
					|| ((k + 1) % _gDriveLineNum == 0))) {
					ratioAvg_border += ratio[k];
					passCount1 += 1;
				} else if ((ptMutualMpTest->Pattern_type == 3)
					   && (ptMutualMpTest->sensorInfo.numKey != 0)
					   && ((k % _gDriveLineNum == 0) || ((k + 2) % _gDriveLineNum == 0))) {
					ratioAvg_border += ratio[k];
					passCount1 += 1;
				} else {
					ratioAvg += ratio[k];
					passCount += 1;
				}
			}
		} else {
			pNormalTestResultCheck[k] = PIN_NO_ERROR;
		}
		normalTestFail_check_Deltac[k] = pNormalTestResultCheck[k];
	}
	/*DEBUG("*** Msg28xx Open Test# normalTestFail_check_Deltac Channel ***\n"); */
	/*DebugShowArray2(normalTestFail_check_Deltac, nRowNum*nColumnNum, 16, 16, nColumnNum); */
#ifndef DISABLE_DOUBLE
	ratioAvg_max =
	    (double)(100 + ptMutualMpTest->ToastInfo.persentDC_VA_Ratio +
		     ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
	ratioAvg_min = (double)(100 - ptMutualMpTest->ToastInfo.persentDC_VA_Ratio) / 100.0;

	ratioAvg_border_max =
	    (double)(100 + ptMutualMpTest->ToastInfo.persentDC_Border_Ratio +
		     ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up) / 100.0;
	ratioAvg_border_min = (double)(100 - ptMutualMpTest->ToastInfo.persentDC_Border_Ratio) / 100.0;
#else
	ratioAvg_max =
	    (int)(100000 + (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000) +
		  (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
	ratioAvg_min = (int)(100000 - (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio * 1000)) / 100;

	ratioAvg_border_max =
	    (int)(100000 + (ptMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000) +
		  (ptMutualMpTest->ToastInfo.persentDC_VA_Ratio_up * 1000)) / 100;
	ratioAvg_border_min = (int)(100000 - (ptMutualMpTest->ToastInfo.persentDC_Border_Ratio * 1000)) / 100;
#endif

	if (passCount != 0) {
		if (passCount1 != 0) {
			ratioAvg_border_move = ratioAvg_border / passCount1;

			ratioAvg_move = ratioAvg / passCount;

			for (i = 0; i < sizeof(ratio) / sizeof(int); i++) {
				if ((ptMutualMpTest->sensorInfo.numKey == 0)
				    && ((i % _gDriveLineNum == 0) || ((i + 1) % _gDriveLineNum == 0))) {
					ratio_move[i] = ratio[i] - ratioAvg_border_move + 1;
				} else if ((ptMutualMpTest->sensorInfo.numKey != 0)
					   && ((i % _gDriveLineNum == 0)
					       || ((i + 2) % _gDriveLineNum == 0))) {
					ratio_move[i] = ratio[i] - ratioAvg_border_move + 1;
				} else {
					ratio_move[i] = ratio[i] - ratioAvg_move + 1;
				}

			}
		} else {
			ratioAvg_move = ratioAvg / passCount;

			for (i = 0; i < sizeof(ratio) / sizeof(int); i++) {
				ratio_move[i] = ratio[i] - ratioAvg_move + 1000;
			}
		}
	} else {
		memcpy(ratio, ratio_move, sizeof(ratio));
	}
	for (j = 0; j < (sizeof(_gDeltaC) / sizeof(int)); j++) {
		if (ptMutualMpTest->Goldensample_CH_0[j] == 0) {
			if (j == 0)
				pNormalTestResult[1] = 1;	/*no golden sample */
			break;
		}

		if (pNormalTestResultCheck[j] == PIN_NO_ERROR) {
			if (_gResult[j] != NULL_DATA) {
				if ((ptMutualMpTest->Pattern_type == 3)
				    && (ptMutualMpTest->sensorInfo.numKey == 0) && ((j % _gDriveLineNum == 0)
					|| ((j + 1) % _gDriveLineNum == 0))) {
					if (checkDoubleValueInRange(ratio_move[j], ratioAvg_border_max,
							ratioAvg_border_min) == 0) {
						pNormalTestResult[1] = 1;
						pNormalTestResultCheck[j] =
						    (u16) (((j / _gDriveLineNum) + 1) * 100 +
							   ((j % _gDriveLineNum) + 1));
					} else {
						pNormalTestResultCheck[j] = PIN_NO_ERROR;
					}
				} else if ((ptMutualMpTest->Pattern_type == 3)
					   && (ptMutualMpTest->sensorInfo.numKey != 0)
					   && ((j % _gDriveLineNum == 0)
					       || ((j + 2) % _gDriveLineNum == 0))) {
					if (checkDoubleValueInRange(ratio_move[j], ratioAvg_border_max,
						ratioAvg_border_min) == 0) {
						pNormalTestResult[1] = 1;
						pNormalTestResultCheck[j] =
						(u16) (((j / _gDriveLineNum) + 1) * 100 + ((j % _gDriveLineNum) + 1));
					} else {
						pNormalTestResultCheck[j] = PIN_NO_ERROR;
					}
				} else {
					/*DEBUG("ratiomove[%d] = %f, ratioAvg_max = %f,
					ratioAvg_min = %f",j,ratio_move[j], ratioAvg_max, ratioAvg_min); */
					if (checkDoubleValueInRange(ratio_move[j], ratioAvg_max, ratioAvg_min) == 0) {
						pNormalTestResult[1] = 1;
						pNormalTestResultCheck[j] =
						(u16) (((j / _gDriveLineNum) + 1) * 100 + ((j % _gDriveLineNum) + 1));
					} else {
						pNormalTestResultCheck[j] = PIN_NO_ERROR;
					}
				}
			} else {
				pNormalTestResultCheck[j] = PIN_NO_ERROR;
			}
		} else {
			normalTestFail_check_Ratio[j] = pNormalTestResultCheck[j];
			continue;
		}
		normalTestFail_check_Ratio[j] = pNormalTestResultCheck[j];
	}

	/*DEBUG("*** Msg28xx Open Test# normalTestFail_check_Ratio Channel ***\n"); */
	/*DebugShowArray2(normalTestFail_check_Ratio, nRowNum*nColumnNum, 16, 16, nColumnNum);*/
	for (k = 0; k < MAX_MUTUAL_NUM; k++) {
		if (ptMutualMpTest->Goldensample_CH_0[k] == 0) {
			pNormalTestResultCheck[k] = PIN_NO_ERROR;
			normalTestFail_check_Deltac[k] = PIN_NO_ERROR;
			normalTestFail_check_Ratio[k] = PIN_NO_ERROR;
		} else {
			continue;
		}
	}

	if ((pNormalTestResult[0] != 0) || (pNormalTestResult[1] != 0))
		nRetVal = -1;

	for (i = 0; i < 2; i++) {
		ptMutualMpTestResult->pCheck_Fail[i] = pNormalTestResult[i];
	}

	for (i = 0; i < sizeof(normalTestFail_check_Deltac) / sizeof(u16); i++) {
		ptMutualMpTestResult->pOpenFailChannel[i] = normalTestFail_check_Deltac[i];
		ptMutualMpTestResult->pOpenRatioFailChannel[i] = normalTestFail_check_Ratio[i];
		ptMutualMpTestResult->pGolden_CH_Max_Avg[i] = ratio_move[i];
	}

	return nRetVal;
}

s8 nNormalTestResult[2] = { 0 };	/*0:golden    1:ratio */
u16 nNormalTestResultCheck[MAX_MUTUAL_NUM] = { 0 };	/*6:max subframe    13:max afe */

int Msg28xxOpenTestEntry(u16 fw_ver)
{
	u16 fmode = MUTUAL_MODE, i;
	s32 nRetVal = 0;
	u16 fail_Row = 0, fail_Column = 0;
	u8 time = 0;
	u16 nScanMode = 0;
	u16 deep_standby = 0;

	TEST_DBG(0, "*** %s() ***\n", __func__);

	deep_standby = ptMutualMpTest->deep_standby;
	_gSenseLineNum = ptMutualMpTest->sensorInfo.numSen;
	_gDriveLineNum = ptMutualMpTest->sensorInfo.numDrv;
	_gResult = ptMutualMpTestResult->pOpenResultData;

    /*_gTestFailChannel = ptMutualMpTestResult->pOpenFailChannel;*/

	/*DisableFingerTouch(); */
	DrvPlatformLyrDisableFingerTouchReport();

_retry_open:

	/*TouchDeviceResetHw(); */
	DrvPlatformLyrTouchDeviceResetHw();

	EnterDBBus();
	/*usleep(100000); */
	mdelay(100);

	/*Stop mcu */
	StopMCU();

	TEST_DBG(0, "** nDriOpening = %d\n", RegGetLByteValue(0x1312));

	switch (ptMutualMpTest->Open_mode) {
	case 0:
		fmode = MUTUAL_MODE;
		break;
	case 1:
	case 2:
		fmode = MUTUAL_SINE;
		break;
	}

	if (Msg28xxSwitchFwMode(&fmode, &deep_standby) < 0) {
		TEST_DBG(0, "*** Msg28xx Open Test# SwitchFwMode failed! ***\n");
		time++;
		if (time < 10)
			goto _retry_open;
		else {
			for (i = 0; i < 2; i++) {
				ptMutualMpTestResult->pCheck_Fail[i] = 1;
			}
			for (i = 0; i < MAX_MUTUAL_NUM; i++) {	/*reduce memory operation instead of memcpy */
				ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
				ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
			}
			nRetVal = -1;
			goto ITO_TEST_END;
		}
	}

	nScanMode = RegGet16BitValueByAddressMode(0x136E, ADDRESS_MODE_16BIT);

	if (fw_ver == 0x0007) {
		if ((nScanMode != KEY_SEPARATE) && (nScanMode != KEY_COMBINE))
			nScanMode = KEY_SEPARATE;
	} else if (fw_ver < 0x0007) {
		nScanMode = KEY_COMBINE;
	}

	if (nScanMode == KEY_SEPARATE) {
		TEST_DBG(0, "fmode = %x\n", fmode);
		if (Msg28xxopen_latter_FW_v1007(fmode) < 0) {
			pr_err("*** Msg28xx Open Test# OpenTest failed! ***\n");
			for (i = 0; i < 2; i++) {
				ptMutualMpTestResult->pCheck_Fail[i] = 1;
			}
			for (i = 0; i < MAX_MUTUAL_NUM; i++) {	/*reduce memory operation instead of memcpy */
				ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
				ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
			}
			nRetVal = -1;
			goto ITO_TEST_END;
		}
	} else {
		TEST_DBG(0, "fmode = %x", fmode);
		if (Msg28xxopen_previous_FW_v1007(fmode) < 0) {
			/*if(Msg28xxopen_latter_FW_v1007(fmode) < 0) { */
			pr_err("*** Msg28xx Open Test# OpenTest failed! ***\n");
			for (i = 0; i < 2; i++) {
				ptMutualMpTestResult->pCheck_Fail[i] = 1;
			}
			for (i = 0; i < MAX_MUTUAL_NUM; i++) {	/*reduce memory operation instead of memcpy */
				ptMutualMpTestResult->pOpenFailChannel[i] = 0xFFFF;
				ptMutualMpTestResult->pOpenRatioFailChannel[i] = 0xFFFF;
			}
			nRetVal = -1;
			goto ITO_TEST_END;
		}
	}

	/*usleep(10000); */
	mdelay(10);

	nRetVal = Msg28xxOpenJudge(0, nNormalTestResult, nNormalTestResultCheck);
	TEST_DBG(0, "*** Msg28xx Open Test# OpenTestOpenJudge return value = %d ***\n", nRetVal);
	if (nRetVal < 0) {
		for (i = 0; i < _gDriveLineNum * _gSenseLineNum; i++) {
			if (nNormalTestResultCheck[i] != 0xffff) {
				fail_Row = i / _gDriveLineNum;
				fail_Column = i % _gDriveLineNum;
				Mstar_save_failed_node(fail_Row, fail_Column);
			}
		}
	}
	ExitDBBus();

ITO_TEST_END:

	/*TouchDeviceResetHw(); */
	DrvPlatformLyrTouchDeviceResetHw();
	/*usleep(300000); */
	mdelay(300);
	/*EnableFingerTouch(); */
	DrvPlatformLyrEnableFingerTouchReport();

	return nRetVal;
}

int Msg28xxOpenTest(u16 fw_ver)
{
	int nRetVal = 0;
	int nRet = 0;

	nRetVal = Msg28xxOpenTestEntry(fw_ver);
	if (nRetVal == 0) {
		nRet = ITO_TEST_OK;
		/*PASS*/ pr_notice("Msg28xx Open Test# MP test success\n");
	} else {
		if (nRetVal == -1) {
			nRet = ITO_TEST_FAIL;
		} else if (nRetVal == -2) {
			nRet = ITO_TEST_GET_TP_TYPE_ERROR;
		} else {
			nRet = ITO_TEST_UNDEFINED_ERROR;
		}

		pr_err("Msg28xx Open Test# MP test failed\n");
	}

	return nRet;
}
